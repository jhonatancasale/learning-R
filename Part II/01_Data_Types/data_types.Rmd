---
title: "Data types"
output: html_notebook
---

## Objects
- character
- numeric (real numbers)
- integer
- complex
- logical (True/False)

The most basic object is a vector

> A vector can only contain objects of the same class

```{r}
attributes(matrix(1:4, 2))
```

### class() function and explicit coercion
```{r}
x <- 0:6
class(x)
as.numeric(x)
as.logical(x)
as.character(x)
```


## Creating Vectors
### Using `c()` function, shorthand for `concatenate`
```{r}
x <- c(0.5, .6)               ## Numeric
print(x)
x <- c(TRUE, FALSE, T, F)     ## logical
print(x)
x <- c("a", "b", "c", 'd')    ## character
print(x)
x <- 9:29                     ## integer
print(x)
x <- 29:9
print(x)
x <- c(1+0i, 2+4i)            ## complex
print(x)
```

### Using the `vector()` function

```{r}
x <- vector('numeric', length = 10)
print(x)
```

### Mixing Objects - What about the following?
```{r}
y <- c(1.7, 'a')          ## character
print(y)
y <- c(T, 2)              ## numeric
print(y)
y <- c('a', T)            ## character
print(y)
```


## Lists

A special type of vector that can contain elements of different classes.

```{r}
x <- list(1, 'a', T, 1 + 4i)
print(x)
```

## Matrices
### Matrices are vectors with a _dimension_ attribute, The dimension attribution is itself an integer vector of length 2 (nrow, ncol)

```{r}
m <- matrix(nrow = 2, ncol = 3)
print(m)
dim(m)
attributes(m)
```

### Matrices are constructes column-wise.

```{r}
m <- matrix(1:6, nrow = 2, ncol = 3)
print(m)
```

Unless

```{r}
m <- matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)
print(m)
```

### Creating a Matrix directly from a vector adding a dimension attribute

```{r}
m <- 1:10
print(m)

dim(m) <- c(2, 5)
print(m)
```

### Using binding operations `cbind()`, `rbind()`

```{r}
x <- 1:3
y <- 10:12

cbind(x, y)
rbind(x, y)
```

## Factors
### Factors are used to represent **categorical** data. Factors can be _unordered_ or _ordered_. One can think of a factor as an integer vector where each integer has a _label_.
- Factors are treated speacilly by modeling functions like lm(), glm()
- Using factors with labels is better than using integers because factors are self-describing

```{r}
x <- factor(c('yes', 'yes', 'no', 'yes', 'no'))
print(x)
table(x)
unclass(x)
```

In the case above, the base level are _no_, because by default, levels are assigned by alphanumerical order, or, explicit by a param

```{r}
x <- factor(c('yes', 'yes', 'no', 'yes', 'no'), levels = c('yes', 'no'))
print(x)
```


## Missing Values
### Missing values are denoted by **NA** or **NaN** for undefined mathematical operations

- is.na() is used to test objects if they are **NA**
- is.nan() is used to test for **NaN**
- **NA** values have a class also, so there are integer **NA**, character **NA**, etc.
- A **NaN** value is also **NA**, but the converse is not true.

```{r}
x <- c(1, 2, NA, 10, 3)

is.na(x)
is.nan(x)

x <- c(1, 2, NaN, NA, 4)

is.na(x)
is.nan(x)
```

## Data Frames
### Are used to store **Tabular Data**

```{r}
x <- data.frame(foo = 1:4, bar = c(T, T, F, F))
print(x)

nrow(x)
ncol(x)
```

## Names Attribute
### R objects can also have naves, which is very useful for writing readble code and self-describing objects.

### Vectors
```{r}
x <- 1:3
names(x)

names(x) <- c('foo', 'bar', 'norf?') # 'baz' ???
print(x)
names(x)
```

### Lists
```{r}
x <- list(a = 1, b = 2, c = 3)
print(x)
print(x$a)
```

### Matrices
```{r}
m <- matrix(1:4, nrow = 2)
dimnames(m) <- list(c('a', 'b'), c('d', 'e'))
print(m)
```

## Reading and Writing data in R